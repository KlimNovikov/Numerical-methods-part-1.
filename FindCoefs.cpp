#include <iostream>
using namespace std;

//------------------------------------------------------------------------------
// Функция: phi
// Описание: Базисная функция. Для данного примера используется система с полиномчиками:
//           phi(n, x) = x^n.
//------------------------------------------------------------------------------
double phi(int n, double x) {
    return pow(x, n);
}

//------------------------------------------------------------------------------
// Функция: phi_k_mult_phi_m_integration
// Описание: Вычисляет численное значение интеграла
//           ∫[a,b] φ_k(x)*φ_m(x) dx
//           Использует составное правило трапеций по узлам, представленным в массиве x.
// Параметры:
//    phi_func - указатель на базисную функцию (phi)
//    k, m     - номера базисных функций
//    x        - массив узлов интегрирования
//    N        - число узлов в массиве x
//------------------------------------------------------------------------------
double phi_k_mult_phi_m_integration(double (*phi_func)(int, double), int k, int m, double* x, int N) {
    double integral = 0.0;
    // Применяем составное правило трапеций
    for (int i = 0; i < N - 1; i++) {
        double h = x[i + 1] - x[i];
        double f1 = phi_func(k, x[i]) * phi_func(m, x[i]);
        double f2 = phi_func(k, x[i + 1]) * phi_func(m, x[i + 1]);
        integral += h * (f1 + f2) / 2.0;
    }
    return integral;
}

//------------------------------------------------------------------------------
// Функция: phi_k_mult_y_integration
// Описание: Вычисляет численное значение интеграла
//           ∫[a,b] u(x) * φ_k(x) dx
//           Использует составное правило трапеций по узлам, представленным в массиве x.
// Параметры:
//    x        - массив узлов интегрирования
//    u        - массив значений аппроксимируемой функции в узлах
//    N        - число узлов в массиве x
//    phi_func - указатель на базисную функцию (phi)
//    k        - номер базисной функции
//------------------------------------------------------------------------------
double phi_k_mult_y_integration(double* x, double* u, int N, double (*phi_func)(int, double), int k) {
    double integral = 0.0;
    // Применяем составное правило трапеций
    for (int i = 0; i < N - 1; i++) {
        double h = x[i + 1] - x[i];
        double f1 = u[i] * phi_func(k, x[i]);
        double f2 = u[i + 1] * phi_func(k, x[i + 1]);
        integral += h * (f1 + f2) / 2.0;
    }
    return integral;
}

//------------------------------------------------------------------------------
// Функция: Gauss(Реализация задания номер 8)
// Описание: Решает систему линейных уравнений A * ANS = B методом Гаусса
//           с выбором главного элемента.
// Параметры:
//    N - размер системы (количество уравнений)
//    A - коэффициенты системы (двумерный массив размером K x K)
//    B - правые части системы (вектор длины K)
//    ANS - вектор, в который записывается найденное решение
//------------------------------------------------------------------------------
void Gauss(int N, double** A, double* B, double* ANS) {

    // Для каждого столбца в матрице.
    for (int i = 0; i < N; ++i) {

        // 1. Находим максимальный элемент в i - ом столбце, который находится под диагональю.
        int pivot = i;
        double maxVal = std::fabs(A[i][i]);         // fabs - функция модуля для нецелых чисел
        for (int row = i + 1; row < N; ++row) {
            double val = std::fabs(A[row][i]);
            if (val > maxVal) {
                maxVal = val;
                pivot = row;
            }
        }

        // 2. Меняем строки так, чтобы максимальный элемент оказался на диагонали.
        if (pivot != i) {
            std::swap(A[i], A[pivot]);  // Меняем указатели на строки
            std::swap(B[i], B[pivot]);  // Меняем местами элементы свободных членов
        }

        // 3. Обнуление элементов под диагональю (Вычитание строк)
        for (int row = i + 1; row < N; ++row) {
            double c = A[row][i] / A[i][i];         // Находим коэффициент, который обнулит определенный элемент i - го столбца под диагональю, A[row][i] - c * A[i][i] = 0
            B[row] -= c * B[i];                     // Используем данный коэффициент для нахождения нового значения в столбце B[row] = B[row] - c * B[i]
            for (int col = i; col < N; ++col) {     // Вычитаем из row строки i - ую строку. Получили 0.
                A[row][col] -= c * A[i][col];
            }
        }

    }

    // После получения верхне-треугольной матрицы(все элементы под диагональю == 0), подставляем значения.
    for (int i = N - 1; i >= 0; --i) {
        double sum = B[i];
        for (int j = i + 1; j < N; ++j) {
            sum -= A[i][j] * ANS[j];
        }
        ANS[i] = sum / A[i][i];
    }
}

//------------------------------------------------------------------------------
// Функция: FindCoefs
// Описание: Формирует систему уравнений для нахождения коэффициентов аппроксимации
//           и решает систему методом Гаусса.
// Аргументы:
//    C - вектор, куда будут записаны найденные коэффициенты
//    K - число коэффициентов (размер базиса)
//    x - массив узлов интегрирования
//    u - массив значений исходной функции в узлах
//    N - число узлов в массиве x (и u)
//------------------------------------------------------------------------------
void FindCoefs(double* C, int K, double* x, double* u, int N) {
    // Выделяем память под СЛАУ
    double** M = new double* [K];
    double* f = new double[K];
    for (int i = 0; i < K; i++) {
        M[i] = new double[K];
    }

    // Заполняем матрицу M по формуле интегралов phi_k_mult_phi_m_integration(...)
    for (int i = 0; i < K; i++) {
        for (int j = 0; j < K; j++) {
            M[i][j] = phi_k_mult_phi_m_integration(phi, i, j, x, N);
        }
    }

    // Заполняем вектор f по формуле phi_k_mult_y_integration(...)
    for (int i = 0; i < K; i++) {
        f[i] = phi_k_mult_y_integration(x, u, N, phi, i);
    }

    // Решаем СЛАУ M * C = f методом Гаусса. 
    Gauss(K, M, f, C);

    // Освобождаем память. 
    delete[] f;
    for (int i = 0; i < K; i++) delete[] M[i];
    delete[] M;
}

//------------------------------------------------------------------------------
// Функция: Approx
// Описание: Вычисляет аппроксимированное значение функции в точке x
//           по найденным коэффициентам C и базисным функциям phi.
//------------------------------------------------------------------------------
double Approx(int K, double x_val, double* C) {
    double y = 0;
    for (int i = 0; i < K; i++) {
        y += C[i] * phi(i, x_val);
    }
    return y;
}

//------------------------------------------------------------------------------
// Описание: Тестовый пример. Аппроксимируется функция u(x) = 3*x^2 + 2*x + 1
//           на интервале [0, 1] методом наименьших квадратов с использованием
//           базиса мономов.
//------------------------------------------------------------------------------
int main() {
    // Параметры аппроксимации
    const int K = 3;    // Число базисных функций (для полинома степени 2)
    const int N = 101;  // Количество узлов интегрирования
    double a = 0.0, b = 1.0;

    // Выделение памяти для массивов узлов x и значений функции u
    double* x = new double[N];
    double* u = new double[N];

    // Заполнение узлов равномерной сеткой и вычисление u(x) = 3*x^2 + 2*x + 1
    double h = (b - a) / (N - 1);
    for (int i = 0; i < N; i++) {
        x[i] = a + i * h;
        u[i] = 3 * x[i] * x[i] + 2 * x[i] + 1;
    }

    // Выделяем память под коэффициенты аппроксимации
    double* C = new double[K];

    // Вычисляем коэффициенты методом наименьших квадратов
    FindCoefs(C, K, x, u, N);

    // Вывод найденных коэффициентов
    cout << "Coefficients:" << endl;
    for (int i = 0; i < K; i++) {
        cout << "C[" << i << "] = " << C[i] << endl;
    }

    // Проверка аппроксимации на нескольких точках
    cout << "\nCompare values of function and approximation:" << endl;
    cout << "  x\t  u(x)\t  Approx(x)" << endl;
    for (double x_val = a; x_val <= b; x_val += 0.1) {
        double true_val = 3 * x_val * x_val + 2 * x_val + 1;
        double approx_val = Approx(K, x_val, C);
        cout << x_val << "\t" << true_val << "\t" << approx_val << endl;
    }

    // Освобождение памяти
    delete[] x;
    delete[] u;
    delete[] C;

    return 0;
}
